#pragma once

#include <cstdint>
#include <type_traits>
#include <ratio>

#include "detail/units_combine.h"

namespace dla {

	template<class Tag, std::intmax_t Num = 1, std::intmax_t Den = 1>
	struct base_unit;
	template<class... Units>
	struct comp_unit;

	namespace tag {
	#define MAKE_TAG(tag) struct tag { static constexpr const char* id = #tag; }
		MAKE_TAG(length);
		MAKE_TAG(time);
		MAKE_TAG(weight);
	#undef MAKE_TAG
	}

	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	struct base_unit {
		using ratio = std::ratio<Num, Den>;
		using tag = Tag;

		float value;

		constexpr explicit operator float() const noexcept;
		constexpr explicit operator float&() noexcept;

		// Operations staying within the same type
		constexpr decltype(auto) operator+=(const base_unit& rhs);
		constexpr decltype(auto) operator-=(const base_unit& rhs);
		constexpr decltype(auto) operator*=(float rhs);
		constexpr decltype(auto) operator/=(float rhs);
	};

	// Dimensionless unit implicitly converts to float
	// Operations will not generate a dimensionless unit though, those can only be generated by users
	template<class Tag, std::intmax_t Den>
	struct base_unit<Tag, 0, Den> {
		using ratio = std::ratio<0, Den>;

		float value;

		constexpr operator float() const noexcept;
		constexpr operator float&() noexcept;
	};

	template<class... Units>
	struct comp_unit {
		// Bug in MSVC 15.9.2 causing the fold expression to emit C2059
	#ifndef _MSVC_LANG
		static_assert((detail::is_base_unit_v<Units> && ...), "Only base_unit is allowed as template argument to comp_unit");
	#endif

		float value;

		constexpr explicit operator float() const noexcept;
		constexpr explicit operator float&() noexcept;

		constexpr decltype(auto) operator+=(const comp_unit& rhs);
		constexpr decltype(auto) operator-=(const comp_unit& rhs);
		constexpr decltype(auto) operator*=(float rhs);
		constexpr decltype(auto) operator/=(float rhs);
	};
	template<>
	struct comp_unit<> {
		float value;

		constexpr operator float() const noexcept;
		constexpr operator float&() noexcept;
	};

	// Operations producing base units
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator-(const base_unit<Tag, Num, Den>& val);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator+(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator-(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator*(const base_unit<Tag, Num, Den>& lhs, float rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator*(float lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator/(const base_unit<Tag, Num, Den>& lhs, float rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator/(float lhs, const base_unit<Tag, Num, Den>& rhs);

	// Operations producing composite units
	template<class... Units>
	constexpr auto operator-(const comp_unit<Units...>& val);
	template<class... Units>
	constexpr auto operator+(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator-(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator*(const comp_unit<Units...>& lhs, float rhs);
	template<class... Units>
	constexpr auto operator*(float lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator/(const comp_unit<Units...>& lhs, float rhs);
	template<class... Units>
	constexpr auto operator/(float lhs, const comp_unit<Units...>& rhs);

	// Operations producing composite units from base units
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class rTag, std::intmax_t rNum, std::intmax_t rDen>
	constexpr auto operator*(const base_unit<lTag, lNum, lDen>& lhs, const base_unit<rTag, rNum, rDen>& rhs);
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class rTag, std::intmax_t rNum, std::intmax_t rDen>
	constexpr auto operator/(const base_unit<lTag, lNum, lDen>& lhs, const base_unit<rTag, rNum, rDen>& rhs);
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator*(const base_unit<lTag, lNum, lDen>& lhs, const comp_unit<Units...>& rhs);
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator/(const base_unit<lTag, lNum, lDen>& lhs, const comp_unit<Units...>& rhs);
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator*(const comp_unit<Units...>& lhs, const base_unit<lTag, lNum, lDen>& rhs);
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator/(const comp_unit<Units...>& lhs, const base_unit<lTag, lNum, lDen>& rhs);

	// Operations producing composite units from composite units
	template<class... lUnits, class... rUnits>
	constexpr auto operator*(const comp_unit<lUnits...>& lhs, const comp_unit<rUnits...>& rhs);
	template<class... lUnits, class... rUnits>
	constexpr auto operator/(const comp_unit<lUnits...>& lhs, const comp_unit<rUnits...>& rhs);

	// Comparison and relational operations
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator==(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator!=(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator>(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator<(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator>=(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator<=(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs);
	template<class... Units>
	constexpr auto operator==(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator!=(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator>(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator<(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator>=(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
	template<class... Units>
	constexpr auto operator<=(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs);
}

#include "units.inl"

namespace dla {
	// Most basic types
	using length_unit = base_unit<tag::length>;
	using time_unit = base_unit<tag::time>;
	using weight_unit = base_unit<tag::weight>;

	// Derived basic types
	using area_unit = base_unit<tag::length, 2>;
	using volume_unit = base_unit<tag::length, 3>;
	using frequency_unit = detail::inverse_t<time_unit>;

	// Derived composite types
	using velocity_unit = decltype(length_unit{} / time_unit{});
	using acceleration_unit = decltype(velocity_unit{} / time_unit{});
	using force_unit = decltype(weight_unit{} * acceleration_unit{});
	using impulse_unit = decltype(weight_unit{} * velocity_unit{});
	using density_unit = decltype(weight_unit{} / volume_unit{});
	using energy_unit = decltype(force_unit{} * length_unit{});
	using power_unit = decltype(energy_unit{} / time_unit{});
	using pressure_unit = decltype(force_unit{} / area_unit{});
}