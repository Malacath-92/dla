#pragma once

#include <cstdint>
#include <type_traits>
#include <ratio>

#include "detail.h"

namespace unit {

	template<class Unit, std::intmax_t Num = 1, std::intmax_t Den = 1>
	struct base_unit;
	template<class... Units>
	struct comp_unit;

	template<class T>
	using inverse_t = detail::inverse_t<T>;
	template<class... Units>
	using sorted_comp_unit_t = detail::sorted_comp_unit_t<Units...>;

	namespace tag {
	#define MAKE_TAG(tag) struct tag { static constexpr const char* id = #tag; }
		MAKE_TAG(length);
		MAKE_TAG(time);
		MAKE_TAG(weight);
	#undef MAKE_TAG
	}

	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	struct base_unit {
		using ratio = std::ratio<Num, Den>;
		using tag = Tag;

		float value;

		constexpr explicit operator float() const noexcept { return value; }
		constexpr explicit operator float&() noexcept { return value; }

		// Operations staying within the same type
		constexpr decltype(auto) operator+=(const base_unit& rhs) {
			value += rhs.value;
			return *this;
		}
		constexpr decltype(auto) operator-=(const base_unit& rhs) {
			value -= rhs.value;
			return *this;
		}
		constexpr decltype(auto) operator*=(float rhs) {
			value *= rhs;
			return *this;
		}
		constexpr decltype(auto) operator/=(float rhs) {
			value /= rhs;
			return *this;
		}
	};

	// Dimensionless unit implicitly converts to float
	// Operations will not generate a dimensionless unit though, those can only be generated by users
	template<class Tag, std::intmax_t Den>
	struct base_unit<Tag, 0, Den> {
		using ratio = std::ratio<0, Den>;

		float value;

		constexpr operator float() const noexcept { return value; }
		constexpr operator float&() noexcept { return value; }
	};

	template<class... Units>
	struct comp_unit {
		// Bug in MSVC 15.9.2 causing the fold expression to emit C2059
	#ifndef _MSVC_LANG
		static_assert((detail::is_base_unit_v<Units> && ...), "Only base_unit is allowed as template argument to comp_unit");
	#endif

		float value;

		constexpr explicit operator float() const noexcept { return value; }
		constexpr explicit operator float&() noexcept { return value; }

		constexpr decltype(auto) operator+=(const comp_unit& rhs) {
			value += rhs.value;
			return *this;
		}
		constexpr decltype(auto) operator-=(const comp_unit& rhs) {
			value -= rhs.value;
			return *this;
		}
		constexpr decltype(auto) operator*=(float rhs) {
			value *= rhs;
			return *this;
		}
		constexpr decltype(auto) operator/=(float rhs) {
			value /= rhs;
			return *this;
		}
	};
	template<>
	struct comp_unit<> {
		float value;

		constexpr operator float() const noexcept { return value; }
		constexpr operator float&() noexcept { return value; }
	};

	// Operations producing base units
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator-(const base_unit<Tag, Num, Den>& val) {
		return base_unit<Tag, Num, Den>{ -float(val) };
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator+(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs) {
		return base_unit<Tag, Num, Den>{ float(rhs) + float(lhs) };
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator-(const base_unit<Tag, Num, Den>& lhs, const base_unit<Tag, Num, Den>& rhs) {
		return lhs + (-rhs);
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator*(const base_unit<Tag, Num, Den>& lhs, float rhs) {
		return base_unit<Tag, Num, Den>{ float(lhs) * rhs };
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator*(float lhs, const base_unit<Tag, Num, Den>& rhs) {
		return rhs * lhs;
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator/(const base_unit<Tag, Num, Den>& lhs, float rhs) {
		return base_unit<Tag, Num, Den>{ float(lhs) / rhs };
	}
	template<class Tag, std::intmax_t Num, std::intmax_t Den>
	constexpr auto operator/(float lhs, const base_unit<Tag, Num, Den>& rhs) {
		using unit = base_unit<Tag, Num, Den>;
		return detail::inverse_t<unit>{ 1.0f / float(rhs) } *lhs;
	}

	// Operations producing composite units
	template<class... Units>
	constexpr auto operator-(const comp_unit<Units...>& val) {
		return comp_unit<Units...>{ -float(val) };
	}
	template<class... Units>
	constexpr auto operator+(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs) {
		return comp_unit<Units...>{ float(rhs) + float(lhs) };
	}
	template<class... Units>
	constexpr auto operator-(const comp_unit<Units...>& lhs, const comp_unit<Units...>& rhs) {
		return lhs + (-rhs);
	}
	template<class... Units>
	constexpr auto operator*(const comp_unit<Units...>& lhs, float rhs) {
		return comp_unit<Units...>{ float(lhs) * rhs };
	}
	template<class... Units>
	constexpr auto operator*(float lhs, const comp_unit<Units...>& rhs) {
		return rhs * lhs;
	}
	template<class... Units>
	constexpr auto operator/(const comp_unit<Units...>& lhs, float rhs) {
		return comp_unit<Units...>{ float(lhs) / rhs };
	}
	template<class... Units>
	constexpr auto operator/(float lhs, const comp_unit<Units...>& rhs) {
		using unit = comp_unit<Units...>;
		return detail::inverse_t<unit>{ 1.0f / float(rhs) } *lhs;
	}

	// Operations producing composite units from base units
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class rTag, std::intmax_t rNum, std::intmax_t rDen>
	constexpr auto operator*(const base_unit<lTag, lNum, lDen>& lhs, const base_unit<rTag, rNum, rDen>& rhs) {
		using lUnit = base_unit<lTag, lNum, lDen>;
		using rUnit = base_unit<rTag, rNum, rDen>;
		return detail::multiply_t<lUnit, rUnit>{ float(lhs) * float(rhs) };
	}
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class rTag, std::intmax_t rNum, std::intmax_t rDen>
	constexpr auto operator/(const base_unit<lTag, lNum, lDen>& lhs, const base_unit<rTag, rNum, rDen>& rhs) {
		return lhs * (1.0f / rhs);
	}
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator*(const base_unit<lTag, lNum, lDen>& lhs, const comp_unit<Units...>& rhs) {
		using lUnit = base_unit<lTag, lNum, lDen>;
		using rUnit = comp_unit<Units...>;
		return detail::multiply_t<lUnit, rUnit>{ float(lhs) * float(rhs) };
	}
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator/(const base_unit<lTag, lNum, lDen>& lhs, const comp_unit<Units...>& rhs) {
		return lhs * (1.0f / rhs);
	}
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator*(const comp_unit<Units...>& lhs, const base_unit<lTag, lNum, lDen>& rhs) {
		using lUnit = comp_unit<Units...>;
		using rUnit = base_unit<lTag, lNum, lDen>;
		return detail::multiply_t<lUnit, rUnit>{ float(lhs) * float(rhs) };
	}
	template<class lTag, std::intmax_t lNum, std::intmax_t lDen, class... Units>
	constexpr auto operator/(const comp_unit<Units...>& lhs, const base_unit<lTag, lNum, lDen>& rhs) {
		return lhs * (1.0f / rhs);
	}

	// Operations producing composite units from composite units
	template<class... lUnits, class... rUnits>
	constexpr auto operator*(const comp_unit<lUnits...>& lhs, const comp_unit<rUnits...>& rhs) {
		using lUnit = comp_unit<lUnits...>;
		using rUnit = comp_unit<rUnits...>;
		return detail::multiply_t<lUnit, rUnit>{ float(lhs) * float(rhs) };
	}
	template<class... lUnits, class... rUnits>
	constexpr auto operator/(const comp_unit<lUnits...>& lhs, const comp_unit<rUnits...>& rhs) {
		return lhs * (1.0f / rhs);
	}

	// Most basic types
	using length_unit = base_unit<tag::length>;
	using time_unit = base_unit<tag::time>;
	using weight_unit = base_unit<tag::weight>;

	// Derived basic types
	using area_unit = base_unit<tag::length, 2>;
	using volume_unit = base_unit<tag::length, 3>;
	using frequency_unit = inverse_t<time_unit>;

	// Derived composite types
	using velocity_unit = decltype(length_unit{} / time_unit{});
	using acceleration_unit = decltype(velocity_unit{} / time_unit{});
	using force_unit = decltype(weight_unit{} *acceleration_unit{});

	// Sanity check
	static_assert(std::is_same_v<detail::sorted_comp_unit_t<length_unit, detail::inverse_t<time_unit>>, velocity_unit>, "Velocity has unexpected type!");


	namespace literals {
		constexpr auto operator ""_m(long double v) { return length_unit{ float(v) }; }
		constexpr auto operator ""_s(long double v) { return time_unit{ float(v) }; }
		constexpr auto operator ""_kg(long double v) { return weight_unit{ float(v) }; }
	}
}