#pragma once

#include <cstdint>
#include <type_traits>
#include <ratio>

#include "type_traits.h"
#include "detail/units_combine.h"

namespace dla {

	template<class Name, std::intmax_t Num, std::intmax_t Den>
	struct unit_tag;
	template<class Tag>
	struct base_unit;
	template<class... Tags>
	struct comp_unit;

	namespace unit_name {
	#define MAKE_UNIT_NAME(unitId, unitSymbol) \
		struct unitId { \
			static constexpr const char* id = #unitId; \
			static constexpr const char* symbol = #unitSymbol; \
		};
		MAKE_UNIT_NAME(length, m)
		MAKE_UNIT_NAME(time, s)
		MAKE_UNIT_NAME(weight, kg)
	#undef MAKE_UNIT_NAME
	}

	template<class Name, std::intmax_t Num, std::intmax_t Den>
	struct unit_tag {
		using ratio_t = std::ratio<Num, Den>;
		using name_t = Name;
	};

	template<class Tag>
	struct base_unit {
		static_assert(is_unit_tag_v<Tag>, "Only unit_tag is allowed as template argument to base_unit");
		
		using tag_t = Tag;
		using ratio_t = typename tag_t::ratio_t;
		using underlying_t = float;

		underlying_t value;

		constexpr explicit operator underlying_t() const noexcept;
		constexpr explicit operator underlying_t&() noexcept;

		// Dimensionless unit implicitly converts to float
		// Operations will not generate a dimensionless unit though, those can only be generated by users
		// constexpr operator float() const noexcept;
		// constexpr operator float&() noexcept;

		// Operations staying within the same type
		constexpr decltype(auto) operator+=(const base_unit& rhs);
		constexpr decltype(auto) operator-=(const base_unit& rhs);
		constexpr decltype(auto) operator*=(underlying_t rhs);
		constexpr decltype(auto) operator/=(underlying_t rhs);
	};

	template<class... Tags>
	struct comp_unit {
		// Bug in MSVC 15.9.2 causing the fold expression to emit C2059
	#ifndef _MSVC_LANG
		static_assert((is_unit_tag_v<Tags> && ...), "Only unit_tag is allowed as template argument to comp_unit");
	#endif

		using underlying_t = float;

		underlying_t value;

		constexpr explicit operator underlying_t() const noexcept;
		constexpr explicit operator underlying_t&() noexcept;

		constexpr decltype(auto) operator+=(const comp_unit& rhs);
		constexpr decltype(auto) operator-=(const comp_unit& rhs);
		constexpr decltype(auto) operator*=(underlying_t rhs);
		constexpr decltype(auto) operator/=(underlying_t rhs);
	};
	template<>
	struct comp_unit<> {
		using underlying_t = float;

		underlying_t value;

		constexpr operator underlying_t() const noexcept;
		constexpr operator underlying_t&() noexcept;
	};

	// Operations producing base units
	template<class Tag>
	constexpr auto operator-(const base_unit<Tag>& val);
	template<class Tag>
	constexpr auto operator+(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator-(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator*(const base_unit<Tag>& lhs, float rhs);
	template<class Tag>
	constexpr auto operator*(float lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator/(const base_unit<Tag>& lhs, float rhs);
	template<class Tag>
	constexpr auto operator/(float lhs, const base_unit<Tag>& rhs);

	// Operations producing composite units
	template<class... Tags>
	constexpr auto operator-(const comp_unit<Tags...>& val);
	template<class... Tags>
	constexpr auto operator+(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator-(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator*(const comp_unit<Tags...>& lhs, float rhs);
	template<class... Tags>
	constexpr auto operator*(float lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator/(const comp_unit<Tags...>& lhs, float rhs);
	template<class... Tags>
	constexpr auto operator/(float lhs, const comp_unit<Tags...>& rhs);

	// Operations producing composite units from base units
	template<class lTag, class rTag>
	constexpr auto operator*(const base_unit<lTag>& lhs, const base_unit<rTag>& rhs);
	template<class lTag, class rTag>
	constexpr auto operator/(const base_unit<lTag>& lhs, const base_unit<rTag>& rhs);
	template<class Tag, class... Tags>
	constexpr auto operator*(const base_unit<Tag>& lhs, const comp_unit<Tags...>& rhs);
	template<class Tag, class... Tags>
	constexpr auto operator/(const base_unit<Tag>& lhs, const comp_unit<Tags...>& rhs);
	template<class Tag, class... Tags>
	constexpr auto operator*(const comp_unit<Tags...>& lhs, const base_unit<Tag>& rhs);
	template<class Tag, class... Tags>
	constexpr auto operator/(const comp_unit<Tags...>& lhs, const base_unit<Tag>& rhs);

	// Operations producing composite units from composite units
	template<class... lTags, class... rTags>
	constexpr auto operator*(const comp_unit<lTags...>& lhs, const comp_unit<rTags...>& rhs);
	template<class... lTags, class... rTags>
	constexpr auto operator/(const comp_unit<lTags...>& lhs, const comp_unit<rTags...>& rhs);

	// Comparison and relational operations
	template<class Tag>
	constexpr auto operator==(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator!=(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator>(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator<(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator>=(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class Tag>
	constexpr auto operator<=(const base_unit<Tag>& lhs, const base_unit<Tag>& rhs);
	template<class... Tags>
	constexpr auto operator==(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator!=(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator>(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator<(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator>=(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
	template<class... Tags>
	constexpr auto operator<=(const comp_unit<Tags...>& lhs, const comp_unit<Tags...>& rhs);
}

#include "units.inl"

namespace dla {
	// Most basic tags
	using length_tag = unit_tag<unit_name::length, 1, 1>;
	using time_tag = unit_tag<unit_name::time, 1, 1>;
	using weight_tag = unit_tag<unit_name::weight, 1, 1>;

	// Most basic units
	using length_unit = base_unit<length_tag>;
	using time_unit = base_unit<time_tag>;
	using weight_unit = base_unit<weight_tag>;

	// Derived basic units
	using area_unit = decltype(length_unit{} * length_unit{});
	using volume_unit = decltype(length_unit{} * length_unit{} * length_unit{});
	using frequency_unit = detail::inverse_t<time_unit>;

	// Derived composite units
	using velocity_unit = decltype(length_unit{} / time_unit{});
	using acceleration_unit = decltype(velocity_unit{} / time_unit{});
	using force_unit = decltype(weight_unit{} * acceleration_unit{});
	using impulse_unit = decltype(weight_unit{} * velocity_unit{});
	using density_unit = decltype(weight_unit{} / volume_unit{});
	using energy_unit = decltype(force_unit{} * length_unit{});
	using power_unit = decltype(energy_unit{} / time_unit{});
	using pressure_unit = decltype(force_unit{} / area_unit{});
}
